# Laravel Eloquent Database Filler

[![Latest Version on Packagist](https://img.shields.io/packagist/v/brahmic/laravel-filler.svg?style=flat-square)](https://packagist.org/packages/brahmic/laravel-filler)
[![GitHub Tests Action Status](https://img.shields.io/github/actions/workflow/status/brahmic/laravel-filler/run-tests.yml?branch=master&label=tests&style=flat-square)](https://github.com/brahmic/laravel-filler/actions?query=workflow%3Arun-tests+branch%3Amaster)

## Содержание

- [Введение](#введение)
- [Особенности пакета](#особенности-пакета)
- [Ограничения](#ограничения)
- [Установка](#установка)
- [Использование](#использование)
  - [Пример для backend](#пример-для-backend)
  - [Пример для frontend](#пример-для-frontend)
- [Поддерживаемые отношения](#поддерживаемые-отношения)
  - [Простые сущности](#простые-сущности)
  - [HasOne](#hasone)
  - [HasMany](#hasmany)
  - [BelongsTo](#belongsto)
  - [BelongsToMany](#belongstomany)
  - [MorphTo](#morphto)
  - [MorphOne](#morphone)
  - [MorphMany](#morphmany)
  - [MorphToMany](#morphtomany)
  - [MorphedByMany](#morphedbymany)
  - [HasOneThrough](#hasonethrough)
  - [HasManyThrough](#hasmanythrough)
- [Особенности вывода данных](#особенности-вывода-данных)
- [Практические рекомендации](#практические-рекомендации)
- [Тестирование](#тестирование)

## Введение

Laravel Eloquent Database Filler - это пакет для Laravel, который решает проблему автоматической гидратации (заполнения) моделей Eloquent вместе с вложенными отношениями на основе данных, получаемых из API запросов.

### Проблематика

При работе с данными через API мы часто получаем и отправляем сущности со вложенными отношениями. При получении данных Laravel предоставляет удобные механизмы работы с отношениями, но при отправке и обновлении данных с вложенными отношениями приходится вручную обрабатывать эти вложенные структуры. Это требует написания большого количества кода для:

1. Создания новых записей в базе данных
2. Обновления существующих записей
3. Удаления записей, которые больше не нужны
4. Поддержания целостности связей между моделями

Этот пакет автоматизирует весь процесс сохранения сложных вложенных структур в базу данных, позволяя работать с данными API "как есть", без необходимости их ручной обработки.

## Особенности пакета

- **Работа с моделями "как есть"** - не требуется дополнительных преобразований данных перед сохранением в базу
- **Unit of Work** - все изменения применяются атомарно; либо все изменения будут внесены, либо (в случае ошибки) изменения не будут внесены вообще
- **Identity Map** - гарантирует, что сущности одного типа и с одинаковым идентификатором являются по сути одним и тем же объектом
- **UUID** - позволяет создавать действительные сущности и связывать их между собой по идентификатору без обращения к базе данных
- **Рекурсивная обработка** - поддерживает произвольный уровень вложенности отношений
- **Автоматическая загрузка связей** - все переданные отношения автоматически добавляются к сущности как загруженные отношения

## Ограничения

В текущей версии пакет работает только с моделями, использующими UUID в качестве первичного ключа.

## Установка

```bash
composer require brahmic/laravel-filler
```

После установки пакет будет автоматически зарегистрирован в Laravel через механизм автообнаружения пакетов.

## Использование

Пакет очень прост в использовании. Основные шаги:

1. Внедрить сервис `Filler` через dependency injection
2. Использовать метод `fill` для заполнения модели данными
3. Вызвать метод `flush` для сохранения всех изменений в базу данных

### Пример для backend

```php
<?php

namespace App\Http\Controllers;

use App\Post;
use Exception;
use Brahmic\Filler\Filler;
use Illuminate\Http\Request;

class PostController
{
    /**
     * @param Request $request
     * @param Filler $filler
     * @return Post
     * @throws Exception
     */
    public function put(Request $request, Filler $filler): Post
    {
        $post = Post::findOrNew($request->get('id'));
        $filler->fill($post, $request->all());
        
        // Здесь можно сделать что-то перед отправкой изменений в базу данных
        
        $filler->flush();
        
        return $post;
    }
}
```

### Пример для frontend

Примерный код для клиентской части (это только пример, не рекомендуется использовать его напрямую):

```js
import uuid from 'uuid/v4'

class Post {
    constructor(data) {
        if (!data.id) {
            data.id = uuid()
        }
        Object.assign(this, data)
    }

    addTag(tag) {
        this.tags.push(tag)
    }

    addImage(image) {
        this.images.push(image)
    }
}

class Tag {
    constructor(data) {
        if (!data.id) {
            data.id = uuid()
        }
        Object.assign(this, data)
    }
}

let post, tags;

function loadTags() {
    fetch('tags')
        .then(response => response.json())
        .then(tagsData => tags = tagsData.map(tagdata => new Tag(tagdata)))
}

function loadPost(id) {
    fetch(`posts/${id}`)
        .then(response => response.json())
        .then(data => post = new Post(data))
}

function savePost(post) {
    fetch(`posts/${post.id}`, {method: 'PUT', body: JSON.stringify(post)})
        .then(response => response.json())
        .then(data => alert(`Post ${data.title} saved!`))
}

loadTags()
loadPost(1)

// После загрузки всего:
post.addTag(tags[0])
post.title = 'Hello World!'

savePost(post)
```

## Поддерживаемые отношения

Пакет поддерживает все стандартные отношения Laravel Eloquent:

### Простые сущности

**Простой пример без ID:**

```json
{
  "name": "Иванов Иван",
  "email": "mail@example.com"
}
```

Поскольку переданные данные не содержат поле `id` (или другое поле, которое было указано в `$primaryKey` модели), гидратор создаст новую сущность и заполнит её переданными данными, используя стандартный метод `fill`. При этом для модели сразу будет сгенерирован `id`.

**Пример с ID:**

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "name": "Иванов Иван",
  "email": "mail@example.com"
}
```

В этом примере был передан `id`, поэтому гидратор попытается найти такую сущность в базе данных. Однако, если такой записи нет, он создаст новую сущность с указанным `id`.
В любом случае, гидратор заполнит эту модель переданными данными для `email` и `name`. Поведение аналогично `User::findORNew($id)`.

### HasOne

Отношение "один к одному":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "name": "Иванов Иван",
  "email": "mail@example.com",
  "profile": {
    "phone": "+7 (999) 123-45-67",
    "address": "г. Москва, ул. Примерная, д. 1"
  }
}
```

В этом случае гидратор обработает сущность первого уровня (пользователя) так же, как в примере с идентификатором. Затем попытается найти профиль пользователя - если не найдет его (а в текущем примере у профиля нет `id`), создаст новый. Если найдет профиль с другим идентификатором, заменит его на вновь созданный. Старый профиль будет удален.

### HasMany

Отношение "один ко многим":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "name": "Иванов Иван",
  "email": "mail@example.com",
  "posts": [
    {
      "id": "1286d5bb-c566-4f3e-abe0-4a5d56095f01",
      "title": "Первая запись",
      "text": "Содержимое первой записи"
    },
    {
      "id": "d91c9e65-3ce3-4bea-a478-ee33c24a4628",
      "title": "Вторая запись",
      "text": "Содержимое второй записи"
    },
    {
      "title": "Новая запись",
      "text": "Содержимое новой записи"
    }
  ]
}
```

В этом примере гидратор обработает каждую запись в массиве `posts`, аналогично примеру с `HasOne`. Кроме того, все записи пользователя, которые не были указаны в переданном массиве, будут удалены.

### BelongsTo

Отношение "принадлежит":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "title": "Новая статья",
  "content": "Содержимое статьи...",
  "author": {
    "id": "1286d5bb-c566-4f3e-abe0-4a5d56095f01",
    "name": "Иванов Иван"
  }
}
```

Хотя этот пример похож на `HasOne`, работает он иначе. Если автор найден гидратором в базе данных, статья будет связана с ним через поле связи. С другой стороны, если такой записи нет, статья получит `null` в этом поле. Все прочие поля связанной записи (автора) будут проигнорированы, поскольку `Post` не является `aggregate root` для `Author`, и поэтому нельзя манипулировать полями автора через объект статьи или создавать новых авторов.

### BelongsToMany

Отношение "многие ко многим":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "title": "Новая статья",
  "content": "Содержимое статьи...",
  "tags": [
    {
      "id": "dcb41b0c-8bc1-490c-b714-71a935be5e2c",
      "pivot": {
        "sort": 0
      }
    },
    {
      "id": "fd5ab8de-c467-4969-9c2e-1a3f93a7bd56",
      "pivot": {
        "sort": 1
      }
    }
  ]
}
```

Этот пример похож на смесь `HasMany` (в том смысле, что все не представленные записи будут удалены из связи) и `BelongsTo` (все поля, кроме поля `$primaryKey`, будут проигнорированы). Обратите внимание, что доступна также работа с данными промежуточной таблицы pivot.

### MorphTo

Полиморфное отношение "принадлежит":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "text": "Это комментарий к посту или к изображению...",
  "commentable": {
    "type": "App\\Post",
    "id": "f85ae98c-09d7-4c13-87a4-a3a4b9b96c50"
  }
}
```

В данном примере мы связываем комментарий с конкретной сущностью через полиморфную связь. Поле `type` указывает класс модели, с которой нужно связать комментарий. Принцип работы аналогичен обычному `BelongsTo`.

### MorphOne

Полиморфное отношение "один к одному":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "title": "Заголовок поста",
  "content": "Содержание поста...",
  "image": {
    "path": "/storage/images/profile.jpg",
    "description": "Основная иллюстрация"
  }
}
```

В этом примере мы добавляем изображение к посту через полиморфную связь. Принцип работы аналогичен обычному `HasOne`.

### MorphMany

Полиморфное отношение "один ко многим":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "title": "Заголовок поста",
  "content": "Содержание поста...",
  "comments": [
    {
      "id": "bcf8e5c7-2d6b-4a8f-a7c3-8a71b68e3937",
      "text": "Первый комментарий"
    },
    {
      "text": "Новый комментарий"
    }
  ]
}
```

В этом примере мы связываем пост с несколькими комментариями через полиморфную связь. Принцип работы аналогичен обычному `HasMany`.

### MorphToMany

Полиморфное отношение "многие ко многим" (с одной стороны):

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "title": "Заголовок поста",
  "content": "Содержание поста...",
  "categories": [
    {
      "id": "dcb41b0c-8bc1-490c-b714-71a935be5e2c",
      "pivot": {
        "featured": true
      }
    },
    {
      "id": "fd5ab8de-c467-4969-9c2e-1a3f93a7bd56"
    }
  ]
}
```

В этом примере мы связываем пост с несколькими категориями через полиморфное отношение "многие ко многим". Принцип работы аналогичен обычному `BelongsToMany`.

### MorphedByMany

Полиморфное отношение "многие ко многим" (с обратной стороны):

```json
{
  "id": "dcb41b0c-8bc1-490c-b714-71a935be5e2c",
  "name": "Технологии",
  "posts": [
    {
      "id": "123e4567-e89b-12d3-a456-426655440000",
      "pivot": {
        "featured": true
      }
    },
    {
      "id": "f85ae98c-09d7-4c13-87a4-a3a4b9b96c50"
    }
  ]
}
```

Этот пример показывает обратную сторону полиморфного отношения "многие ко многим". Категория связана с постами через промежуточную таблицу. Принцип работы аналогичен `MorphToMany`.

### HasOneThrough

Отношение "один к одному через":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "name": "Россия",
  "cities": [
    {
      "id": "bcf8e5c7-2d6b-4a8f-a7c3-8a71b68e3937",
      "name": "Москва",
      "shops": [
        {
          "name": "Центральный магазин",
          "address": "Тверская ул., 1"
        }
      ]
    }
  ],
  "firstShop": {
    "name": "Центральный магазин",
    "address": "Тверская ул., 1"
  }
}
```

В данном примере отношение `firstShop` является `HasOneThrough`. Через промежуточную модель `City` мы получаем связь с первым магазином страны. Пакет корректно обрабатывает такие отношения.

### HasManyThrough

Отношение "один ко многим через":

```json
{
  "id": "123e4567-e89b-12d3-a456-426655440000",
  "name": "Россия",
  "cities": [
    {
      "id": "bcf8e5c7-2d6b-4a8f-a7c3-8a71b68e3937",
      "name": "Москва",
      "shops": [
        {
          "name": "Магазин 1",
          "address": "Тверская ул., 1"
        },
        {
          "name": "Магазин 2",
          "address": "Ленинский пр., 15"
        }
      ]
    }
  ],
  "shops": [
    {
      "name": "Магазин 1",
      "address": "Тверская ул., 1"
    },
    {
      "name": "Магазин 2",
      "address": "Ленинский пр., 15"
    }
  ]
}
```

В данном примере отношение `shops` является `HasManyThrough`. Через промежуточную модель `City` мы получаем связь со всеми магазинами страны. Пакет корректно обрабатывает такие отношения.

> Важно отметить, что **всё вышеописанное работает рекурсивно** и действительно для любой степени вложенности.

## Особенности вывода данных

Стоит отметить, что все переданные отношения будут добавлены к сущности для вывода.
Например:

```php
$user = $filler->fill(User::class, [
    'id' => '123e4567-e89b-12d3-a456-426655440000',
    'name' => 'Иванов Иван',
    'email' => 'mail@example.com',
    'roles' => [
        [
            'id' => 'dcb41b0c-8bc1-490c-b714-71a935be5e2c',
            'pivot' => ['sort' => 0],
        ],
    ],
]);

$user->relationLoaded('roles'); // true
// Хотя flush еще не выполнен, все отношения уже зарегистрированы
// и нет необходимости загружать их дополнительно.
// Вызов $user->roles не вызовет повторный запрос к базе данных.

$filler->flush();
// Только после этого сущность со всеми своими связями будет сохранена в базе данных.
```

## Практические рекомендации

### Структура API запросов

Для эффективного использования пакета рекомендуется придерживаться следующей структуры при построении API:

1. **Плоские эндпоинты для списков** - при получении списков сущностей используйте плоскую структуру без вложенных отношений для повышения производительности

2. **Детальные эндпоинты с отношениями** - при получении одной сущности включайте необходимые отношения

3. **Соблюдайте идемпотентность** - используйте PUT запросы для обновления данных, передавая полное состояние сущности

4. **UUID для новых сущностей** - создавайте UUID на клиентской стороне для новых сущностей, чтобы упростить связывание вложенных структур

### Оптимизация производительности

1. **Ограничивайте глубину вложенности** - слишком глубокая вложенность может привести к производительности

2. **Избегайте циклических зависимостей** - проектируйте структуру API таким образом, чтобы избежать циклических зависимостей между сущностями

3. **Используйте кэширование** - для часто запрашиваемых данных используйте кэширование на уровне приложения

### Лучшие практики безопасности

1. **Валидация данных** - всегда валидируйте входящие данные перед передачей их в Filler

2. **Контроль доступа** - реализуйте проверки доступа перед сохранением сущностей в базу данных

3. **Транзакции** - метод flush() уже использует транзакции, но при необходимости можно обернуть его в дополнительную транзакцию

## Тестирование

Пакет имеет полный набор тестов для проверки его функциональности. Для запуска тестов можно использовать удобный скрипт:

```bash
# Запуск всех тестов
./run-tests.sh all

# Запуск только модульных тестов
./run-tests.sh unit

# Запуск только функциональных тестов
./run-tests.sh feature
```

Подробная информация о тестировании доступна в [README-TESTING.md](README-TESTING.md).